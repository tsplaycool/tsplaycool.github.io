<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用SpringCloud Zuul过程中遇到的问题]]></title>
    <url>%2F2019%2F04%2F14%2Fzuul%2F</url>
    <content type="text"><![CDATA[背景使用SpringCloud Zuul开发一个可后台配置的网关系统，用户将转发规则写入数据库，Zuul网关启动的时候去数据库加载路由规则，进行请求转发。Zuul对接的后台服务不涉及服务注册与发现组件，从API接口捞取后台服务列表和地址，网关只需要根据规则将请求指向后台其中一台即可。采用Zuul该搭建该系统的原因在于，Zuul的转发原理可以让我们很方便的对请求的内容就行包装和处理。而基于Nginx做开发成本太高，涉及的编程语言门槛和其他一些因素。该网关系统采用@EnableZuulServer进行注解，无须涉及RibbonRoutingFilter。转发过程实际只需要根据规则将请求指向后台特定IP机器即可，因此该系统的route过滤器与SimpleHostRoutingFilter非常类似，完全可以基于SimpleHostRoutingFilter的源码做订制开发，从而来满足我们这个需求。请求URL编码问题通过网关发起的Get请求，到后台服务器时，上送的参数会被强制执行URLEncode。在SimpleHostRoutingFilter过滤器中，有一个参数forceOriginalQueryStringEncoding，顾名思义，强制采用原始请求的编码格式，即不对Get请求参数做编解码。SimpleHostRoutingFilter过滤器中构造HttpRequest的方法如下，构建HttpRequest12345678protected HttpRequest buildHttpRequest(String verb, String uri, InputStreamEntity entity, MultiValueMap&lt;String, String&gt; headers, MultiValueMap&lt;String, String&gt; params, HttpServletRequest request) &#123; HttpRequest httpRequest; String uriWithQueryString = uri + (this.forceOriginalQueryStringEncoding ? getEncodedQueryString(request) : this.helper.getQueryString(params)); ...&#125;该方法在构建url的时候，会根据forceOriginalQueryStringEncoding这个值执行不同的操作，当为true的时候，调用getEncodedQueryString方法，如下图所示，获取QueryString12345private String getEncodedQueryString(HttpServletRequest request) &#123; String query = request.getQueryString(); return (query != null) ? "?" + query : ""; &#125;&#125;可以看到，getEncodedQueryString方法直接返回request.QueryString，将不会对请求参数进行编解码操作。而this.helper.getQueryString方法会对请求参数做编解码处理。因此，只需要将forceOriginalQueryStringEncoding设置为true即可。该参数可以在Zuul的properties属性中配置，该参数在构造SimpleHostRoutingFilter中初始化的时候，是通过调用properties.isForceOriginalQueryStringEncoding()方法来进行初始化的。302重定向问题FormBodyWrapperFilterX-Forward-For与Host]]></content>
      <categories>
        <category>zuul</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】用户态与内核态]]></title>
    <url>%2F2019%2F02%2F25%2Fuserandkernal%2F</url>
    <content type="text"><![CDATA[前言最近在学习Netty，学习五种IO模型，其中涉及一些时间片轮转，上下文切换的东西，自14年考完研后，这些东西都忘光了。百度搜索了一些关于用户态与内核态的知识，特记录一下以防遗忘。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud高版本的zuul路由状态查看]]></title>
    <url>%2F2019%2F01%2F16%2Fzuul%2F</url>
    <content type="text"><![CDATA[前言最近在研究SpringCloud Zuul的时候，发现通过 /routes无法查看路由信息，上网搜索了一些信息，发现都是低版本的SpringCloud的解决方案。Finchley版本和Greenwich版本并不适用。低版本的SpringCloud是基于springboot1 的版本，可以通过以下方式配置：1、引入spring-cloud-starter-zuul2、引入spring-boot-starter-actuator3、properties文件设置management.security.enabled=false4、访问/routes显示端点信息，访问/routes?format=details显示详细的端点信息SpringCloud高版本由于Finchley版本和Greenwich版本的Spring Cloud采用SpringBoot2.0，security的操作有改动，导致management.security.enabled=false会报错：Deprecated:A global security auto-configuration is now provided…”而且zuul的代码全部放到了Netflix包下，访问/routes的方式也有所变化，具体的操作步骤如下：1、引入spring-cloud-starter-netflix-zuul2、引入spring-boot-starter-actuator3、properties文件设置management.endpoints.web.exposure.include=*4、访问/actuator/routes显示端点信息，访问/actuator/routes/details显示详细的端点信息]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>zuul</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Gateway自定义过滤器实现IP Hash路由]]></title>
    <url>%2F2019%2F01%2F14%2FRouteToRequestUrl%2F</url>
    <content type="text"><![CDATA[现状公司转型微服务架构，将之前机器上所有已部署微服务拆分集群部署。微服务地址采用资源管理平台统一管理维护，包括微服务IP、集群数据等，未采用服务注册与发现组件。需求1、从资源管理平台获取服务器IP地址等相关参数；2、相同源IP转发到相同服务器，采用IP Hash方式；实现SpringCloud Gateway支持自定义过滤器，通过继承RouteToRequestUrlFilter类来实现IP Hash。SpringCloud Gateway过滤器分为两类，Gateway Filter和Global Filter，前者是针对匹配命中的过滤，有两种方式来实现，实现GatewayFilter接口、继承AbstractGatewayFilterFactory类，后者是针对全局路由的过滤器，可以采用添加@Component注解的方式来注册。SpringCloud Gateway的全局过滤器如下图所示：我们需要做的就是实现一个自定义的全局过滤器CustomRouteToRequestUrlFilter，在该过滤器中设置IP Hash后的真实URL地址。代码如下：CustomRouteToRequestUrlFilter.java1234567891011121314151617181920212223@Component public class CustomRouteToRequestUrlFilter extends RouteToRequestUrlFilter &#123; private List&lt;String&gt; mUrlList = new ArrayList&lt;String&gt;() &#123; &#123; add("http://10.0.0.1"); add("http://10.0.0.2"); add("http://10.0.0.3"); &#125; &#125;; @Override public int getOrder() &#123; return 10001; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; ServerHttpRequest request = exchange.getRequest(); String address = request.getRemoteAddress().getAddress().getHostAddress(); int num = Math.abs(address.hashCode()) % mUrlList.size(); URI mergedUrl = URI.create(mUrlList.get(num)); exchange.getAttributes().put(ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR, mergedUrl); return chain.filter(exchange); &#125;&#125;以上代码可以进行优化，通过处理”x-forward-for”以获取真实IP地址。此处暂略。WebFlux通过ServerWebExchange类来处理Http Request和Http Response。首先取得IP地址，然后将IP地址做Hash得到一个整型，再根据服务器数量求余，最后得到所选择的服务器。以上代码需要注意的地方在于，需要设置Order为10001，大于RouteToRequestUrlFilter的返回值（10000），这样才能将优先级置于RouteToRequestUrlFilter之下。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>IP Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Gateway基于静态URL的Ribbon负载均衡]]></title>
    <url>%2F2019%2F01%2F09%2FgatewayRibbon%2F</url>
    <content type="text"><![CDATA[前言SpringCloud Gateway是Netflix旗下开源的API网关，项目比较新，网上资源也比较少，因此坑比较多吧。说到SpringCloud Gateway，肯定都会与Zuul进行对比。Zuul分为Zuul1和Zuul2两个版本，Zuul1是采用同步阻塞的方式，使用多线程来实现，而Zuul2则是采用异步非阻塞的事件驱动。SpringCloud Gateway与Zuul2一样，基于异步非阻塞的事件驱动。而SpringCloud Zuul则是采用的Zuul1这个同步阻塞的方式，可能是由于Zuul2出来比较慢，Netflix等不及了，就自己搞了一个异步非阻塞的SpringCloud Gateway。有人在Github提问，SpringCloud 后续是否会集成Zuul2，官方给了否定答复。既然都有了异步非阻塞的Gateway，那么也就没必要再集成Zuul2到SpringCloud了。两者的性能对比（zuul1和Gateway），https://github.com/spencergibb/spring-cloud-gateway-bench 。ProxyAvg LatencyAvg Req/Sec/Threadgateway6.61ms3.24klinkered7.62ms2.82kzuul12.56ms2.09knone2.09ms11.77k需求1、根据配置，将指定源IP路由到某台特定的服务器，以便灰度发布验证。2、采用Web端进行路由配置更新。3、默认规则，采用IP Hash路由到固定服务器。根据以上三个需求点，只需要使用API网关与负载均衡器，不需要服务注册与发现组件，因此需要采用静态URL进行路由配置。根据多方面权衡以及业务可行性分析，技术栈决定采用SpringCloud Gateway。原因有以下几点：1、Gateway支持 RemoteAddr Route Predicate Factory，可以满足需求点1。2、Gateway支持 Actuator API，支持RestFul刷新路由配置，可以满足需求点2。3、采用Ribbon，自定义路由规则，以及支持静态服务器地址配置，可以满足需求点3。实现application.yml12345678910111213141516171819202122spring: cloud: gateway: routes: -id: wpstan uri: lb://customRibbon predicates: -RemoteAddr=99.6.150.163ribbon: eureka: enabled: false //必须要关闭eureka的服务注册与发现customRibbon: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule //随机规则 listOfServers: http://99.12.98.215:8080,http://99.12.98.215:8081,http://99.12.98.215:8082management: endpoints: web: exposure: include: '*'//配置actuator api使用，暴露端点 第六行的lb表示匹配规则为loadBalance负载均衡，规则名为customRibbon。第十二行表示该负载均衡规则采用Ribbon，后面就是Ribbon的配置。主要就是listOfServers这个静态URL配置，由于我不需要去动态获取服务注册与发现，因此可以在此写死。需要注意的就是必须要把ribbon.eureka.enabled置为false。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构简介（单一架构VS微服务架构）]]></title>
    <url>%2F2019%2F01%2F03%2Fmicsvrintroduce%2F</url>
    <content type="text"><![CDATA[前言最近，关于微服务有很多争论。几乎所有的IT公司都在讨论微服务。当我们将微服务跟传统的单一架构比较时，可以很容易理解它。几乎每个企业应用都有相似的分层架构：1.表现层：用户的交互界面。2.业务逻辑：应用的内在业务逻辑。3.数据库访问：几乎所有的应用都需要访问数据库，SQL或NoSQL都行。4.应用集成：应用之间交互是相当常见的。这些通常是通过Web服务调用（SOAP或REST）或消息传递来实现的。即使应用有清晰的、逻辑上模块化架构，但是，大部分应用会被作为单一架构打包和发布。这么做是有一定优势的。单一架构的优势1.开发相当简单。2.测试也非常简单。仅仅启动应用，然后开始端对端的测试。我们也能毫无困难的使用Selenium进行自动化测试。3.部署单一应用程序是很简单;只需将打包的应用程序复制到服务器。4.扩展是很简单的。我们仅仅需要增加单一架构的新实例。并通过负载均衡器将负载分配到新实例上，但是，随着整体应用程序的规模增长，可伸缩性将成为一个严重的问题。单一架构的劣势1.灵活性: 单一架构不够灵活。我们不能使用不同的技术。技术堆栈从一开始就决定了，并自始至终遵循。一旦开发成熟，有时就很难升级技术堆栈版本，更不用说增量地采用新技术了。2.可靠性: 不可靠。如果一个特性出现故障，整个应用程序可能会出现故障。3.开发速度: 单一架构的开发非常缓慢。对于新的团队成员来说，理解和修改大型单一架构应用程序的代码是很困难的。代码质量会随着时间的推移而下降。随着代码库的增大，IDE会过载，速度会变慢。应用程序越大，启动时间越长。所有这些因素都会对开发人员的生产力产生巨大的影响。4.构建复杂应用: 由于技术方面的限制，很难构建复杂的应用程序。5.可伸缩性: 单一架构的应用程序一旦变大，就很难扩展。我们可以创建新的单体实例，并要求负载均衡器将流量分配给新的实例，但是整体架构不能随着负载的增加而扩展。应用程序实例的每个副本都将访问所有数据，这将降低缓存的效率，并增加内存消耗和I/O流量。而且，不同的应用程序组件有不同的资源需求——一个可能是CPU密集型组件，而另一个可能是内存密集型组件。使用单一架构，我们不能独立地扩展每个组件。6.持续部署: 持续部署极其困难。大型单一架构的应用程序实际上是频繁部署的一个障碍。为了更新一个组件，我们必须重新部署整个应用程序。由于上述单一架构应用程序的缺点，微服务体系结构正日益受到人们的欢迎。那么什么是基于微服务的体系结构呢?简而言之，微服务体系结构风格是一种将单一架构应用程序开发为一组小服务的方法，每个小服务都在自己的流程中运行，并与轻量级机制通信(通常通过RESTful web服务或消息传递)。这些服务是围绕业务功能构建的，可以通过完全自动化的部署机制独立部署。这些服务的集中化管理非常少，它们可能使用不同的编程语言开发，使用不同的数据存储技术。微服务是小型的、可独立部署的、支持云计算的单元。微服务架构如何解决单一架构的缺点1.灵活性: 微服务体系结构非常灵活。不同的微服务可以用不同的技术开发。由于微服务更小，代码基础就更少了，所以升级技术堆栈版本并不是那么困难。而且，我们可以毫无困难地逐步采用新技术。2.可靠性: 微服务体系结构可以非常可靠。如果一个功能崩溃，整个应用程序就不会崩溃。我们可以在相应的微服务中修复这个问题并立即部署它。3.开发速度: 微服务体系结构中的开发非常快。由于微服务的代码量要小得多，因此新团队成员理解和修改代码并不困难。他们从一开始就很有成效。代码质量维护良好。IDE要快得多。微服务的启动时间要短得多。所有这些因素都大大提高了开发人员的生产力。4.构建复杂的应用程序: 使用微服务体系结构，很容易构建复杂的应用程序。如果正确地分析应用程序的特性，我们可以将其分解为独立的组件，这些组件可以独立部署。然后，甚至独立组件也可以进一步分解为小的独立任务，这些任务可以作为微服务独立部署。确定微服务的边界非常具有挑战性。这实际上是一个渐进的过程，但是一旦我们决定使用微服务，就很容易开发，因为在技术上没有限制。5.可伸缩性: 可伸缩性是微服务体系结构中的一个主要优点。每个微服务可以单独缩放。由于单个微服务的大小要小得多，因此缓存变得非常有效。6.持续部署: 持续部署变得更容易。为了更新一个组件，我们只需要重新部署那个特定的微服务。正如我前面提到的，当我们将微服务体系结构与传统的单一体系结构进行比较时，可以很容易地理解它，但是在微服务之前，已经有类似的体系结构可用。是的，我说的是SOA(面向服务的体系结构)。SOA已经存在了20年。如果您已经使用过SOA并熟悉它的概念，那么理解SOA和微服务体系结构之间的差异可能会非常令人困惑。事实上，两者的共同点多于不同点。在下一篇关于微服务的文章中，我将介绍SOA、SOA和微服务体系结构之间的相似性，当然还有它们之间的区别。（转自IT牧场）]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>microservice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年终总结]]></title>
    <url>%2F2018%2F12%2F17%2F2018summary%2F</url>
    <content type="text"><![CDATA[前言2018年是戊戌狗年，本人26周岁。工作硕士毕业两年半，这两年半一直在搞web。毕业前主要接触的是移动端开发，转型后开始搞Web开发。之前对JS、CSS接触的不多，基本是零经验。我比较喜欢思考其所以然，所以在转型中还是上手的比较快。由于公司偏稳重，目前Web端还是采用服务器渲染的方式，并没有做前后端分离。在用CSS画一些前端页面的时候，真心感觉不如Android的五大布局来得爽，后来接触到了Flex布局，才发现这个真是神器，什么布局都可以搞定。做了两年多Web开发，个人感觉Web开发比移动客户端开发有意思，移动端开发给人的感觉比较闭塞、基本就是移动端的性能调优、架构也只是源代码的架构，而Web端的涉及技术更多，更广。刚毕业那会，整个项目，几百号人，都是基于单体应用的开发模式，各个业务模块耦合严重，牵一发而动全身，上线投产也是很困难的事。庆幸的是直属领导技术在公司算不错的，对项目做了微服务化改造，把单体应用搞成了50多个微服务，开发运维效率有很大提高。今年前半年除了做业务需求，学习了一些前后端分离的概念和思想，接触了Node.js、webpack、MVVM框架的VUE以及响应式编程等，这些东西让我在后续开发微信小程序中获益不少。 由于后来这个前后端分离的改造给了别的组去搞，就没继续搞下去了。下半年开始接触Spring Cloud微服务，服务治理、API网关、负载均衡、容错限流等，Eureka、Consul、Nacos、Zuul、Hystrix等，很多微服务相关的技术都要开始慢慢学习，这也是明年要做的事。今年买了很多本关于微服务和spring的书籍，给人的感觉就是国外人写书写的通俗易懂，真正是教你学习。国内很多都是滥竽充数、代码占比接近一半，看的人累。举个例子：《spring 微服务实战》（spring microservices in action)、《spring cloud微服务实战》，后者是国内作者翟永超编写，差距是真大。小结，今年知识面广度有所增加，希望明年深度能进一步提升。生活领证了，结婚了，老婆的工作还是一如既往的忙。希望老婆来年能轻松一点，一起生个白白胖胖的孩子。今年跟老婆一起去了苏州、乌镇、迪士尼等周边游。老婆心心念的哈尔滨一直没去，有机会肯定会去的。今年最开心的事情除了领证结婚，就是父亲体检一切正常。]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用DNS实现服务发现]]></title>
    <url>%2F2018%2F12%2F07%2Fdns%2F</url>
    <content type="text"><![CDATA[前言众所周知，DNS的作用是将域名转成IP，进而让客户端浏览器获取主机的IP地址进行HTTP通信。DNS服务器中，域名能够关联各种不同类型的资源。除了我们非常熟悉的A解析（解析成IP地址）或者是CNAME解析（解析成别的域名）等，DNS还可以提供其他一些资源的解析，例如SRV（服务定位）、PTR（其他域名引用）以及TXT（文本数据）。DNS解析A记录将域名解析成IPV4的形式。AAAA记录将域名解析成IPV6的形式。CNAME将域名解析成其他域名。MX邮件服务器地址解析。TXT将域名解析成文本文件类型。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 简介]]></title>
    <url>%2F2018%2F11%2F28%2Fspringboot%2F</url>
    <content type="text"><![CDATA[前言作为一个SpringBoot新人，在学习中有诸多疑惑，慢慢梳理出来、但求拨云见日。SpringBoot和SpringSpring是容器，是管理对象生命周期的容器。开发的时候，由Spring容器来处理对象的生命周期。Spring容器能够帮助我们来管理生命周期的前提是我们需要对Spring进行配置。而SpringBoot的出现，简化了这种XML的配置过程，这也是SpringBoot的一大优势。当然，SpringBoot也不单单仅有这一个优势，更多的优势可以自行百度一下。HelloWorldSpringBoot自带了java web服务器，引入SpringBoot后，在main方法中注册Application启动类，即可运行。页面输出HelloWorld，需要配置一个@Controller，用来响应浏览器请求。控制器@Controller 用来处理http的请求，@RestController用来返回Json数据格式，@RequestMapping用来配置Url映射。可以使用GetMapping来简化Get操作。Controller1234567public class HelloController &#123; @RequestMapping(value = "/hello",method = RequestMethod.GET)//等价于@GetMapping(value="/hello") @ResponseBody public String sayHello() &#123; return "Hello，Spring Boot！"; &#125;&#125;当注解写成@RestController的时候，可以直接返回一个序列化的JSON对象。下面的代码将返回一个JSON格式的CMB对象。RestController12345678@RestController@RequestMapping("/config")public class ConfigController &#123; @RequestMapping("/hr") public CMB currentUser() &#123; return CMBUtils.getCurrentCMB(); &#125;&#125;Controller可以返回字符串，可以返回序JSON列化后的对象，那要怎么返回HTML页面呢？可以使用前端页面模板。thymeleaf首先在配置文件中引入thymeleaf的包，然后再Controller中编写响应请求代码，返回html的页面名字。其中，ModelMap是用来与Html页面进行数据交互的。Controller12345@RequestMapping(method = RequestMethod.GET)public String getBookList(ModelMap map) &#123; map.addAttribute("bookList",bookService.findAll()); return "bookList";&#125;bookList.html的页面部分内容如下所示：bookList.html1234567&lt;tr th:each="book : $&#123;bookList&#125;"&gt; &lt;th scope="row" th:text="$&#123;book.id&#125;"&gt;&lt;/th&gt; &lt;td&gt;&lt;a th:href="@&#123;/book/update/&#123;bookId&#125;(bookId=$&#123;book.id&#125;)&#125;" th:text="$&#123;book.name&#125;"&gt;&lt;/a&gt;&lt;/td&gt; &lt;td th:text="$&#123;book.writer&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;book.introduction&#125;"&gt;&lt;/td&gt; &lt;td&gt;&lt;a class="btn btn-danger" th:href="@&#123;/book/delete/&#123;bookId&#125;(bookId=$&#123;book.id&#125;)&#125;"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;数据库操作SpringBoot可以方便的连接多种数据库，比如MySql，ElasticSearch等。在学习过程中梳理出了以下几个需要了解的点：ORM框架主流的有hibernate以及mybatis，区别在于前者无须写sql，通过对象操作数据库，后者通过编写更加灵活的sql语句来操作数据库。ORM是JPA规范中的一个思想体现，JPA规范包含了ORM。JPA、spring-data-jpa、hibernate三者之间的关系，JPA是Java Persistence API缩写，是JAVA持久化规范，spring-data-jpa对具体的JPA实现做了封装，默认采用hibernate实现，能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。操作步骤：1、引入spring-data-jpa；2、编写Entity类；3、编写Repository类；4、调用方法Book.java123456789@Entitypublic class Book implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String writer; ....get set ....BookRepository.java12345/** * Book 数据持久层操作接口 */public interface BookRepository extends JpaRepository&lt;Book, Long&gt; &#123;&#125;BookServiceImpl.java1234567891011121314/** * Book 业务层实现 */@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired BookRepository bookRepository; @Override public List&lt;Book&gt; findAll() &#123; return bookRepository.findAll(); &#125;......从上面代码中可以看到，在业务服务层只需要引入BookRepository后，就可以操作数据库中相关数据，很方便。已经具备了搭建一套对外服务的功能，包括响应请求、操作数据、返回数据。代码结构规范的SpringBoot工程分层结构应该包括如下项：应用监控sprig-boot-starter-actuatorSpringCloud]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的gitment评论报错]]></title>
    <url>%2F2018%2F11%2F28%2Fhexogitmenterror%2F</url>
    <content type="text"><![CDATA[Gitment报错今天发现我博客hexo采用的github issue的评论系统gitment出现了以下报错：所有评论Error: API rate limit exceeded for 107.178.194.84. (But here’s the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)解决方案：无需解决原因：这是github的自我保护机制，防止未登陆用户重复调用API。点击下方github登陆按钮登陆后，错误消失。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XX-Net科学上网]]></title>
    <url>%2F2018%2F11%2F28%2Fxxnet%2F</url>
    <content type="text"><![CDATA[前言Great Wall 不多说，中国特色，哈哈哈。XX-Net这个跟之前用的GoAgent貌似一样的原理，先去谷歌申请一个小应用程序，然后利用这个来科学上网。详细介绍都在GitHub上XX-Net，目前有25539个星。可以自己去谷歌申请appid，也可以用xx-net自带的。网速还可以，目前用的最好用的科学上网工具，支持windows、mac、Android。本方法需要ipv6隧道，如果用mac连接手机热点，且手机支持4G，则可以直接上网。如果是宽带，需要配置ipv6协议，教程上有详细说明。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo next主题SEO优化]]></title>
    <url>%2F2018%2F11%2F21%2Fhexoseo%2F</url>
    <content type="text"><![CDATA[前言我在大学期间使用过ZBlog、WordPress等博客系统。而Hexo与这两者的区别在于，Hexo是静态博客系统。Hexo无需数据库作为存储，也无需服务器端渲染，直接将页面以Html的格式输出给用户。全球最大男性交友社区github提供了GitPage解决方案，使得开发者可以直接将静态Html页面发布到web上。这样也避免了购买web云服务器，却只用来处理静态页面的不划算，免费的总是最好的。GitPage我们可以将Hexo生成的页面push到GitPage中来发布，GitPage是Github提供的个人页面的个性化展示空间。可以通过创建一个Repository，进入设置页面激活GitPage，而后可以通过 (用户名.github.io) 的方式访问。wpstan.github.io。GitPage非常友好的提供了域名映射，我们可以使用自己简短的域名来访问博客，例如本站的域名tanRD.com。SEO 之 keywords搜索引擎会在页面的&lt;head>标签中查询&lt;keywords>的mete定义，收录时会根据keywords进行索引，因此这个很有必要进行优化。打开_config.yml文件，找到keywords所在的行，添加自己希望通过搜索引擎索引的关键字。关键字个数五六个应该就差不多了，关键字个数对搜索引擎的具体影响，我也不懂。上述改动是针对首页的关键字优化，我们还必须优化每一个文章页面的keywords,打开/themes/next/layout/_partials/head.swig文件，找到以下代码：通过上述代码可以知道，next首先去页面上找keywords，没有就使用tags标签来设置keywords值，再没有就使用主题设置的keywords。我这里将keywords在页面脚手架中定义，使得在new 文章的时候，默认带上这个参数，这样就可以自定义添加keywords了。同时修改上述代码，将页面中自定义的keywords以及页面标签作为最后的keywords。下面是本文的顶部标题，title: Hexo next主题SEO优化 date: 2018-11-21 19:10:30 url_suffix: hexoseo tags: [&apos;hexo&apos;,&apos;seo&apos;] categories: 博客 keywords: [&apos;next&apos;,&apos;搜索引擎优化&apos;] 最终在本页面中得到的keywords如下图所示：可以看到有两个keywords属性，上方的是刚才代码拼接的结果，下方的是Hexo自带的，可以删除这个自带的。打开文件路径：/Hexo/node_modules/hexo/lib/plugins/helper/open_graph.js，将下方代码注释掉即可。if (keywords) { if (typeof keywords === &apos;string&apos;) { result += meta(&apos;keywords&apos;, keywords); } else if (keywords.length) { result += meta(&apos;keywords&apos;, keywords.map(tag =&gt; { return tag.name ? tag.name : tag; }).filter(keyword =&gt; !!keyword).join()); } } SEO 之 静态URL静态URL是指当前页面的地址不会变动，永久存在的网页地址。搜索引擎喜欢收录静态URL，以静态URL作为当前收录页面的索引。如果说当前文章页面经常改动，可想而知，搜索引擎难以收录。Hexo默认是按照日期和文章名字生成当前文章的URL地址，可以查看_config.yml文件，找到permalink这个配置。# URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: https://www.tanrd.com root: / permalink: :year/:month/:day/:url_suffix/ permalink_defaults: 我这里增加了url_suffix作为URL后缀，默认是以文章的文件名拼接URL。而我文件名可能需要设置成中文，方便我查找，但是中文文字在地址栏会被HTML Encode转成html编码，将导致链接很长。因此这里我设置了一个url_suffix，主动设置文章后缀名。这个url_suffix地址在文章中不应该经常修改，特别是搜索引擎收录之后，修改地址将会导致搜索以前之前收录的链接变成死链，无法访问，非常不利于SEO。因此在创建文章的时候，手动设置了这个url_suffix后，就不要再修改了。在SEO之keywords这个章节中，我已经展示了我这个文章的定义头部分，可以看到url_suffix设置的是hexoseo。在地址栏中显示的地址是https://www.tanrd.com/2018/11/21/hexoseo/SEO 之 百度搜索引擎由于之前百度爬虫将github搞挂了，github屏蔽了百度爬虫的抓取。但是没有关系，我们可以采用github的pages和coding的pages来发布自己的博客。coding这个公司已经被腾讯收购，是国内的一家类似github的网站，国内比较出名的git平台还有码云，我们公司最近也引入码云。我这个域名www.tanrd.com 是通过阿里云购买的，在域名解析的时候，只需将百度爬虫解析到国内的coding page即可。在解析的时候选择CNAME将百度指向coding的pages地址，这个意思是将百度爬虫的DNS解析指向国内的coding pages，我这里是wpstan.coding.me。阿里云非常方便的给我们提供了解析线路选择，有多种选择，根据自己需求来决定。除了百度指向coding的pages，其他的线路都默认指向github的pages，毕竟github的CDN很多，网速也还能接受。SEO 之 SiteMapSitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。我这里搞了两sitemap，一个是sitemap.xml，可以打开https://www.tanrd.com/sitemap.xml访问；一个专门针对百度的baidusitemap.xml，地址是https://www.tanrd.com/baidusitemap.xml。在Hexo中安装很容易，只需要执行如下命令即可：npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --saveSEO 之 robots.txt这个文件的作用是制定搜索引擎的爬取规则，所有正规搜索引擎都遵守该标准。新建robots.txt放在source的根目录下，修改其中内容为：User-agent: * Allow: / Allow: /archives/ Allow: /categories/ Allow: /tags/ Allow: /about/ Disallow: /js/ Disallow: /images/ Disallow: /css/ Disallow: /fonts/ Sitemap: https://www.tanrd.com/sitemap.xml Sitemap: https://www.tanrd.com/baidusitemap.xml 本站的robots.txt地址为https://www.tanrd.com/robots.txtSEO 之 nofollow当搜索引擎在爬取文章页面的时候，如果文章中有外链，可能会将爬虫引出我们的网站，因此有必要屏蔽这种情况。首先安装hexo-autonofollownpm install hexo-autonofollow --save再在外层_config.yml中添加配置，将nofollow设置为true：# 外部链接优化 nofollow: enable: true exclude: # 例外的链接，可将友情链接放置此处 - &apos;yousite&apos; 再重新生成的时候，可以看到出站链接自动加上了一系列参数：&lt;a href=&quot;https://github.com/XX-net/XX-Net&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;XX-Net&lt;/a&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序云开发]]></title>
    <url>%2F2018%2F11%2F19%2Fclouddev%2F</url>
    <content type="text"><![CDATA[前言微信小程序依托微信平台，给用户提供类似App的操作体验。俗话说一流公司订标准，小程序开发语言规范由Tencent制定。小程序开发需要了解前端相关知识，JS、HTML、CSS足以。学习过前端MVVM框架的开发人员，可以很容易上手。闲来无事，周末在家倒腾了一下小程序开发，在这里记录一下心得。小程序云开发一般来说开发一个App或者Web页面，都需要一个服务提供者，用来存储用户相关数据，或者给Web页面提供服务端渲染来完成与用户之间交互。但是微信出了一个小程序云开发，可以直接充当云端数据库，看起来特别牛逼的样子。这样一来，就不需要购买各种云服务器来提供服务了。小程序云开发可以让用户在云端编写JS Function函数，相当于FaaS平台（函数即服务）。微信提供免费基础版云平台套餐给开发者使用，开发者也可以花钱升级套餐。我以个人身份注册了一个小程序，个人身份的开发者貌似只能开发一些特定类目的小程序，比价、教育什么的。本人开发了一个小App，后续见github。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next - Gemini主题修改]]></title>
    <url>%2F2018%2F10%2F19%2Fgeminimodify%2F</url>
    <content type="text"><![CDATA[前言在Hexo的模板中选择了Next主题，在Next主题中看中了Gemini风格的页面。但是有一些小点不符合本人审美，特意修改了一下，以满足我自己的视觉体验。页面宽度修改chrome浏览器F12查看到页面的内容宽度占比为75%，找到themes中的next文件夹，进入/source/css/_variables/目录，打开Gemini.styl文件。可以看到以下内容：也可以设置$body-bg-color，改变页面背景色。页面底部主题信息删除打开themes中的next文件夹，找到_config.yml文件，修改footer下面的配置为false即可。copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false 页面顶部黑色线条删除打开themes中的next文件夹，找到/source/css/_common/components/header/headerband.styl文件，删除background样式即可。.headband { height: $headband-height; background: $headband-bg; } 静态资源压缩可以通过安装hexo-all-minifier来进行静态资源压缩，减少网络请求时候的数据包，加快网站响应速度。可以对html、css、js、images进行压缩，即把重复的代码合并，把多余的空格去掉，用算法对images进行压缩。npm install hexo-all-minifier --save再在外层_config.yml中添加配置，可以分别对html、js、css、image进行处理： html_minifier: enable: true ignore_error: false exclude: css_minifier: enable: true exclude: - &apos;*.min.css&apos; js_minifier: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos; image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false 再重新生成的时候，可以看到页面上的静态资源已经被压缩，Size这一栏数据量有所减少。下面是压缩前后的传输数据量对比： 代码高亮第一种方式：首先安装 hexo-prism-plugin插件，执行如下命令：npm install hexo-prism-plugin --save 然后修改_config.yml，添加如下配置：prism_plugin: mode: &apos;preprocess&apos; # realtime/preprocess theme: &apos;default&apos; line_number: false # default false custom_css: &apos;path/to/your/custom.css&apos; # optional 相关配置字段说明如下：mode:realtime (在浏览器实时解析代码)preprocess (在node环境中先解析代码)theme:defaultcoydarkfunkyokaidiasolarizedlighttomorrowtwilightatom-darkbase16-ateliersulphurpool.lightcbduotone-darkduotone-earthduotone-forestduotone-lightduotone-seaduotone-spaceghcolorshopscotchpojoaquevsxonokailine_number:true (显示行号)false (默认, 隐藏行号)no_assetstrue (停止加载资源文件)false (默认, 加载js和css文件)第二种方式：直接用自带的next主题，可以在配置文件中修改自己喜欢的样式# Code Highlight theme # Available value: # normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: night 在写博客插入代码的时候，需要指定开发语言，才会显示不同的颜色样式。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gemini</tag>
      </tags>
  </entry>
</search>
