<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP2.0中的二进制帧层原理]]></title>
    <url>%2F2020%2F02%2F04%2Fhttp2%2F</url>
    <content type="text"><![CDATA[前言Http2.0中涉及到一个二进制帧层，而OSI网络模型中有一个数据链路层，数据链路层的协议数据单元也叫做帧。然而两者并不是同一个东西，Http2.0是运行在TCP传输层之上的应用层。Http2.0中的二进制帧层其实可以看做是基于传输层和应用层之间的一个分层。Http1和Http2Http1.0 每一次请求都必须创建一个新的TCP连接。Http1.1 下一次请求可以沿用上一次请求的TCP连接，但是请求之间是串行的，必须等上一个请求结束后，下一个请求才能发起。Http2.0 可以将多个请求同时在一个TCP连接中发出。原理TCP层传输，是将上一层协议的数据分割成多个不同序号的报文进行传输，通过滑动窗口协议和一些ACK、Syn等字段进行全双工通信（两端需要对传输报文序号进行确认，双向通信，信道冲突时候可能会采用csma/cd等算法进行处理）。Http1.1 直接将字符形式的请求报文交付给TCP层进行传输，在应用层必须解析出请求head和body才能完成通信。Http2.0 将应用层的数据经过二进制帧层处理，将不同的请求拆成不同的stream，由stream的id进行标记，请求的stream被分割成多种类型的帧，其中包括head帧和data数据帧。正是因为有了stream的id标记、以及各种不同类型的帧，确保了请求和响应的有序重组。例如请求a.js和b.css，a.js对应的stream的id为1，b.css对应的stream的id为2，a.js的head帧为head1，数据帧为data1，b.js的head帧为head2，数据帧为data2。浏览器可以将head1、data1、head2、data2同时放入TCP信道进行报文传输，在TCP层，可能会进一步对这些数据进行拆分，拆成不同报文序号进行传输，但是可以无需关注这层是如何拆分、组装的。因为可以在Http2.0的二进制帧层进行有序处理，将接收到的stream的id为1的放一起处理，接收到的stream的id为2的放一起处理。通过这种方式就可以解决Http1.1中存在的请求阻塞问题，试想：假如a.js的处理很慢，服务器可以先将b.css的处理结果返回，因为采用了stream的id编号，所以可以在Http2.0的二进制帧层先对b.css的stream的id进行重组，将b.css的响应交付于应用层处理。总结Http2.0 引入了一个二进制帧层，将并发的请求转成不同的stream流传输，每个stream的分帧都带有特定的序号id，这就保证了请求响应的数据可以在二进制帧层进行重组，即使传输过程是无序的。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Http2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名301重定向到www]]></title>
    <url>%2F2020%2F01%2F12%2F301_redirect%2F</url>
    <content type="text"><![CDATA[前言将博客部署到gitpage，访问速度是一个大问题，每次TTFB都是四五秒。因此，选用虚拟主机来部署静态html博客，加快博客访问速度，这个时候就会遇到一个SEO的问题。当我们在采用gitpage的时候，可以通过在根目录加一个CNAME文件，内容为www.tanrd.com ，github主机会自动将tanrd.com永久重定向到www.tanrd.com 。而在采用虚拟主机部署的时候，这个301重定向就需要自己来设置了。在阿里云设置域名解析的时候，既设置了根域名tanrd.com解析到主机，也设置了www.tanrd.com 解析到主机，然而搜索引擎收录的内容都是之前以www开头的域名。为了继续沿用一个域名作为SEO的主要域名，需要将不带www的域名解析到带www的域名。代码虚拟主机支持php解析，因此在hexo的_posts目录中增加一个index.php文件，同时在虚拟主机设置优先读取的首页为index.php。根据域名判断为tanrd.com的时候，在请求head中增加301重定向信息，当域名为www.tanrd.com 的时候，直接include返回hexo自动生成的index.html文件。&lt;?php $the_host = $_SERVER['HTTP_HOST']; $request_uri = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : ''; if($the_host == 'tanrd.com') { header('HTTP/1.1 301 Moved Permanently'); header('Location: http://www.tanrd.com'.$request_uri); }else{ //require('index.html'); require每次都首先加载，include执行到再加载 include('index.html'); } ?&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Zuul路由和Ribbon的listOfServers]]></title>
    <url>%2F2020%2F01%2F09%2FcustomZuulRibbon%2F</url>
    <content type="text"><![CDATA[前言脱离Eureka等服务注册与发现组件，使用Zuul和Ribbon来做网关负载均衡，可以在application.properties中配置listOfServer指定后台主机地址。然而这种方式存在一些弊端，强依赖配置文件，无法做到实时变更和维护。通过构建自定义的路由加载类、service-id等配置，可以实现从数据库或者其他地方加载路由规则。同时还可以实现自定义的ServerList、IRule、IPing等来维护网关的可扩展性。详细源码在github上源码地址。application.properties采用配置文件的路由规则配置通常采用如下方式。1234567891011121314#定义名为ironman的路由规则，负载均衡的主机使用ribbon的listOfServers配置#可以采用以下方式配置路由规则的IRule、IPing、ServerList等#&lt;clientName&gt;.ribbon.NFLoadBalancerClassName: Should implement ILoadBalancer#&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName: Should implement IRule#&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName: Should implement IPing#&lt;clientName&gt;.ribbon.NIWSServerListClassName: Should implement ServerList#&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName: Should implement ServerListFilterzuul.routes.ironman.path=/**zuul.routes.ironman.service-id=flyfly.ribbon.listOfServers=http://localhost:9000,http://localhost:9001fly.ribbon.NFLoadBalancerRuleClassName=com.wpstan.custom.ribbon.CustomRulefly.ribbon.NFLoadBalancerPingClassName=com.wpstan.custom.ribbon.CustomPingfly.ribbon.NIWSServerListClassName=com.wpstan.custom.ribbon.CustomServerListCustomZuulConfig.java自定义Zuul配置类，采用CustomRouteLocator类来加载路由规则。12345678910111213141516171819@Configurationpublic class CustomZuulConfig &#123; private final ZuulProperties zuulProperties; private final ServerProperties serverProperties; @Autowired public CustomZuulConfig(ZuulProperties zuulProperties,ServerProperties serverProperties)&#123; this.zuulProperties = zuulProperties; this.serverProperties = serverProperties; &#125; @Bean public CustomRouteLocator routeLocator()&#123; CustomRouteLocator routeLocator = new CustomRouteLocator(serverProperties.getServlet().getContextPath(), zuulProperties); return routeLocator; &#125;&#125;CustomRouteLocator.java自定义Zuul路由规则加载类，重写locateRoutes方法，首先从配置加载，再从其他地方加载。12345ZuulProperties.ZuulRoute zuulRoute = new ZuulProperties.ZuulRoute();zuulRoute.setId("ironman");zuulRoute.setServiceId("fly");zuulRoute.setPath("/**");routesMap.put(zuulRoute.getPath(), zuulRoute);CustomRibbonAutoConfiguration.java自定义Ribbon的配置类，用以指定RibbonClient采用CustomRibbonClientConfiguration类进行初始化。123@RibbonClients( defaultConfiguration = &#123;CustomRibbonClientConfiguration.class&#125;)CustomRibbonClientConfiguration.java自定义ribbon相关的配置类，可以在此类中构造IPing、IRule、ServerList等数据。可以从数据库配置中根据ribbon的service-id来构造不同的IPing、IRule、ServerList等实现类。当service-id没有构造的时候，会从此类中进行构造。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CustomRibbonClientConfiguration extends RibbonClientConfiguration &#123; @Bean @ConditionalOnMissingBean @Override public IClientConfig ribbonClientConfig() &#123; IClientConfig config = super.ribbonClientConfig(); //可以增加一些配置，例如Ping后台主机的时间间隔5s config.set(CommonClientConfigKey.NFLoadBalancerPingInterval, 5); //可以在此设置Ping实现类（无需重写ribbonPing，base中会根据如下配置反射构造IPing），也可以使用方法直接构造，例如下面的ribbonPing()方法 config.set(CommonClientConfigKey.NFLoadBalancerPingClassName,"com.wpstan.custom.ribbon.CustomPing"); //设置MaxAutoRetries为2，确保某个服务挂的瞬间，ServerStats的Successive Connection Failure大于或等于 //ServerStats中的connectionFailureThreshold的默认次数3。这样ServerStats的isCircuitBreakerTripped才被置位短路。 //在Retry重试的时候，CustomRule中Choose下一个服务的时候，确保之前的服务已经短路，选用下一个服务，否则可能继续选择不可用服务导致报错。 //还有一种方式就是调小ServerStats的connectionFailureThreshold。 config.set(CommonClientConfigKey.MaxAutoRetries, 2); return config; &#125; @Bean @ConditionalOnMissingBean @Override public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) &#123; CustomServerList serverList = new CustomServerList(); serverList.initWithNiwsConfig(config); return serverList; &#125; @Bean @ConditionalOnMissingBean @Override public IRule ribbonRule(IClientConfig config) &#123; CustomRule rule = new CustomRule(); rule.initWithNiwsConfig(config); return rule; &#125; @Bean @ConditionalOnMissingBean @Override public IPing ribbonPing(IClientConfig config) &#123; return new CustomPing(); &#125;&#125;CustomServerList.java自定义ServerList类，等价于重写listOfServer配置，通过getUpdatedListOfServers来维护service-id对应的后台主机服务。PollingServerListUpdater类定时任务更新时，会调用getUpdatedListOfServers方法。1234567891011121314151617181920212223public class CustomServerList implements ServerList&lt;Server&gt;, IClientConfigAware &#123; private IClientConfig clientConfig; @Override public List&lt;Server&gt; getInitialListOfServers() &#123; return getUpdatedListOfServers(); &#125; @Override public List&lt;Server&gt; getUpdatedListOfServers() &#123; List&lt;Server&gt; servers = new ArrayList&lt;&gt;(); Server server1 = new Server("http://localhost:9000"); Server server2 = new Server("http://localhost:9001"); servers.add(server1); servers.add(server2); return servers; &#125; @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; this.clientConfig = iClientConfig; &#125;&#125;CustomPing.java自定义IPing类，通过定时任务，维护后台机器活性，采用HttpClient与后台机器通信。12345678910111213141516171819202122232425262728293031323334353637@Override public boolean isAlive(Server server) &#123; String urlStr = ""; if (this.isSecure) &#123; urlStr = "https://"; &#125; else &#123; urlStr = "http://"; &#125; urlStr = urlStr + server.getId(); urlStr = urlStr + this.getPingAppendString(); boolean isAlive = false; HttpClient httpClient = HttpClientBuilder.create().build(); HttpUriRequest getRequest = new HttpGet(urlStr); String content = null; try &#123; HttpResponse response = httpClient.execute(getRequest); content = EntityUtils.toString(response.getEntity()); isAlive = response.getStatusLine().getStatusCode() == 200; if (this.getExpectedContent() != null) &#123; if (content == null) &#123; isAlive = false; &#125; else if (content.equals(this.getExpectedContent())) &#123; isAlive = true; &#125; else &#123; isAlive = false; &#125; &#125; &#125; catch (IOException var11) &#123; var11.printStackTrace(); &#125; finally &#123; getRequest.abort(); &#125; return isAlive; &#125;CustomRule.java自定义IRule类，RibbonRoutingFilter过滤器会根据请求的url地址，首先匹配service-id，然后根据service-id匹配的IRule实现类，从IRule中获取一个目的主机地址，当前CustomRule采用IP Hash算法，同时根据ServerStatus维护的主机状态获取目的主机。12345678910111213141516171819202122232425public Server choose(ILoadBalancer lb, Object key) &#123; //首先获取可用的后台主机，可用的后台主机会根据定时任务不断调用ServerList中的getUpdatedListOfServers()方法来维护 List&lt;Server&gt; upServerList = lb.getReachableServers(); RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); //获取IP地址，根据IP地址做Hash String ip = request.getRemoteAddr(); int hashCode = Math.abs(ip.hashCode()); int num = hashCode % upServerList.size(); LoadBalancerStats loadBalancerStats = ((AbstractLoadBalancer) lb).getLoadBalancerStats(); //ServerStats类维护的是后台主机的状态 ServerStats serverStats = loadBalancerStats.getSingleServerStat(upServerList.get(num)); System.out.println("当前机器失败次数：" + serverStats.getServer().getId()+" "+serverStats.getSuccessiveConnectionFailureCount()); int count = 0; //轮训判断后台服务是否短路挂起 while (serverStats.isCircuitBreakerTripped()) &#123; if (++count &gt;= upServerList.size()) &#123; return null; &#125; num = (num + 1) % upServerList.size(); serverStats = loadBalancerStats.getSingleServerStat(upServerList.get(num)); &#125; System.out.println("#####:选择了" + serverStats.getServer().getId()); return upServerList.get(num); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>zuul</tag>
        <tag>ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InetAddress.getLocalHost导致应用响应慢]]></title>
    <url>%2F2019%2F12%2F11%2FresponseSlow%2F</url>
    <content type="text"><![CDATA[前言DMZ区的测试网关应用，部署在linux系统。有一天突然响应很慢，应用重启速度也很慢，但是访问部分url网速正常。通过排查发现是InetAddress.getLocalHost方法导致，该方法会通过内核指令获取本机host中配置内容，而host内容被运行自动化工具修改过。解决在hosts文件中增加：1127.0.0.1 machineName（主机名）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DocFx生成Asp.NetCore文档]]></title>
    <url>%2F2019%2F11%2F25%2Fdocfx%2F</url>
    <content type="text"><![CDATA[前言在看微软官方文档的时候，提到”To build the API Browser, we used open standards and tools. At its core, we leveraged DocFX - the open documentation generation toolchain, along with Xamarin’s mdoc application.”微软的.Net文档是通过DocFx来生成，通过该工具，可以在本地内网容器环境搭建Asp.Net Core的文档。DocFx1、下载DocFx（github releases），windows系统设置环境变量2、执行命令，生成一个初始化的dockfx项目1docfx init -q3、将本地nuget仓库中的Asp.Net Core源码源码dll和对应xml文件，拷贝到上述生成的项目的src目录中4、需要修改docfx.json为元数据目标文件为：src/**/*.dll。4、执行命令，构建API文档。docfx.json可以设置默认的icon、logo、模板等信息。1docfx docfx_project\docfx.json 备注1、直接将源码中的src拷贝到项目的src目录，通过docfx.json修改配置为”src/**/*.sln”进行构建会导致问题，问题：标签不能正确链接指向跨解决方案的类，可能是未经过nuget restore。2、为了避免上述问题，可以直接从nuget本地源中将Asp.Net Core的dll和dll对应的xml文件，拷贝到docfx项目的src中。3、修改docfx.json中的”metadata”配置，将”src”下的”files”改成”src/**/*.dll”即可。4、docfx.json中的template配置，默认是default，可以切换成statictoc，statictoc比default生成的文件大，因为每个生成的html文件都包含了toc搜索的内容，而default模板打包出来的是单独加载toc.html的文件，这就导致页面在切换的时候会出现闪动的情况。]]></content>
      <categories>
        <category>NetCore</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>DocFx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步IO和异步IO]]></title>
    <url>%2F2019%2F11%2F22%2FIO%2F</url>
    <content type="text"><![CDATA[同步IO线程遇到IO请求，首先通过系统调用使得CPU进入内核态执行指令，系统内核通过调用驱动程序进行硬件IO处理。要么通过CPU将硬件缓冲区的IO数据拷贝到内核区域，要么通过DMA直接将硬件缓冲区的IO数据拷贝到内核区域。这两种方式的区别在于是否需要CPU介入这个拷贝过程。但是这两种方式都是同步IO，因为线程都必须等待数据从硬件缓冲区拷贝到内存区域，才能进行下一步操作。在这种情况下进行高并发操作，必须依赖很多线程。而很多线程在等待内存中IO数据准备好的过程中，会因为中断导致CPU上下文切换而丢失CPU所有权，CPU转而执行其他就绪线程，上下文切换是比较消耗CPU资源的，在大多数X86或者X64架构的CPU中，线程上下文切换的时间间隔大约为15ms。异步IO在基于DMA的基础上，不需要CPU参与IO拷贝，那么就可以给CPU腾出空间执行其他逻辑。异步IO相比同步IO，工作线程可以执行其他请求，而不会阻塞等待IO请求执行完毕。可以极大提升系统性能，最大程度降低线程数量，减少线程上线文切换产生的性能损失。之所以能实现异步IO，在于当前线程向设备发出异步IO时候，请求被传给设备驱动程序，设备驱动程序处理IO请求时并不会等待IO请求完成，而是将IO请求加入到设备驱动程序的队列中，然后返回一个IO处理中的信号。应用程序不需要挂起等待IO请求的完成，从而可以继续执行其他任务。总结1、同步IO会阻塞线程，该模式下提高并发性能必须增加很多线程，但是很多线程会因为上下文切换而造成性能损失。2、异步IO实现高性能IO有三点：减少IO上下文切换；异步非阻塞线程；避免内存复制。3、开发高性能服务器框架的必备条件在于减少线程、避免内存复制、避免线程阻塞。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>同步</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWS亚马逊云VPS操作]]></title>
    <url>%2F2019%2F11%2F16%2Fawsvps%2F</url>
    <content type="text"><![CDATA[美国区AppStore账号下载SS客户端账号：tangyuan9102@gmail.com密码：POIU1234abcdMAC终端连接AWS EC212chmod 400 wpstan.pemssh -i "wpstan.pem" ubuntu@ec2-18-162-148-176.ap-east-1.compute.amazonaws.com安装ShadowSocks服务端12345678910111213141516171819202122232425sudo apt-get updatesudo apt-get install python-pipsudo pip install shadowsockssudo vim /etc/shadowsocks.json&#123; "server":"0.0.0.0", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "9000":"password0",//端口和密码 "9001":"password1", "9002":"password2", "9003":"password3", "9004":"password4" &#125;, "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125;sudo ufw allow 9000 //开启端口sudo ufw allow 9001 //开启端口...sudo ssserver -c /etc/shadowsocks.json -d start//开启服务/bin/ps axu | grep ssserver | grep -v grep//检查服务启动状态sudo ssserver -c /etc/shadowsocks.json -d stop//关闭服务安装Google BBR拥塞控制123sudo wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shsudo chmod +x bbr.shsudo ./bbr.shshadowsocks-libev使用ss-server命令替换原有ssserver，性能比shadowsocks好。相比原版Shadowsocks，libev(c#)版本提供了更多的特性支持；而关于ShadowsocksR(Python)，Shadowsocks-libev率先支持AEAD Cipher，并向ShadowsocksR学习引进了Obfs(Simple-Obfs)，且提供稳定的周期性更新；长远来看，ShadowsocksR更倾向于向none加密化和Obfs化发展，而Shadowsocks-libev则倾向于向强化Cipher的方向发展，两者有不同的侧重点。简单来说，ShadowsocksR更侧重消除特征以更好穿过GFW，而Shadowsocks-libev则追求更高的安全性，综合起来并无优劣之分simple-obfs 和 v2ray-plugin不加插件，单独使用shadowsocks很容易被封，可以使用simple-obfs或者v2ray-plugin插件做混淆。simple-obfs已经不推荐，github上不再维护，可以使用v2ray-plugin。用于混淆 Shadowsocks 流量的工具，目的是让ss-local的流量更像正常的http流量，思路是在原来的 Shadowsocks 流量上叠加一层加密，使得 G和F谐W 无法判断是否正常的网站流量。v2ray-plugin使用https做加密，应该比simple-obfs强很多，但是需要自己申请域名和证书。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>AWS</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot应用启停脚本]]></title>
    <url>%2F2019%2F08%2F31%2Fstartstopjar%2F</url>
    <content type="text"><![CDATA[启动脚本123456nohup /usr/bin/java -jar Gateway.jar --spring.profiles.active=prd --server.ssl.key-store-type=JKS --server.port=443 --server.ssl.key-store=***.jks(jks类型秘钥) --server.ssl.key-password=***(密码)--server.ssl.ciphers=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA_,SSL_RSA_WITH_RC4_128_SHA &amp;停止脚本1ps -ef|grep java |grep Gateway.jar |grep -v grep |awk '&#123;print $2&#125;' |xargs kill -9备注nohup 命令会默认在当前路径生成nohup.out日志，可以在末尾&amp;之前加上1nohup *** &gt;/dev/null 2&gt;&amp;1 &amp;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DevOps流水线中bat编译脚本获取git仓库版本信息]]></title>
    <url>%2F2019%2F05%2F31%2Fdevops%2F</url>
    <content type="text"><![CDATA[背景DevOps流水线可以发布web应用A和B，其中A和B在编译时候依赖于C模块，A、B、C存储在不同的git仓库，C作为SubModule添加到A和B仓库中。需要查询A和B应用使用到的C仓库的代码版本，在流水线构建的时候执行git命令拉取C的commit-id即可。代码12345678910111213141516171819202122232425262728@echo offsetlocal enabledelayedexpansion //变量延迟执行set dstDir=%1 //将版本信息写入的目标文件夹set baseDir=%2 //在该目录执行git命令获取版本号（也就是上文所述C仓库目录）if &quot;%dstDir%&quot; neq &quot;&quot; &#123; cd %baseDir% if exist temp.ini del temp.ini git rev-parse HEAD&gt;&gt;temp.ini set /p commitId=&lt;temp.ini del temp.ini (git log --pretty=format:%%cd !commitId! -1 --date==format:&quot;%%Y-%%m--%%d %%H:%%M:%%S&quot;)&gt;&gt;temp.ini set /p commitTime=&lt;temp.ini del temp.ini rem 获取当前编译时间 2019-11-11 11：11：11 set compileTime=%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2% cd %dstDir% rem 将数据输出到文件dst.ini中 if exist dst.ini del dst.ini echo CommitId=!commitId!&gt;&gt;dst.ini echo CommitTime=!commitTime!&gt;&gt;dst.ini echo CompileTime=!compileTime!&gt;&gt;dst.ini&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>bat</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API网关性能优化之PoolingHttpClientConnectionManager]]></title>
    <url>%2F2019%2F05%2F20%2Fhttpclient%2F</url>
    <content type="text"><![CDATA[笔记使用自定义zuul网关的时候，与后台主机通信采用HttpClient类，使用PoolingHttpClientConnectionManager作为HttpClient的链接管理对象，可以有效减少创建连接的资源开销，尤其是网关类应用，与后台主机通信的时候，长连接比较合适。HttpClient在与后台主机通讯时候，会启用本地的随机一个tcp端口与远程主机的tcp端口进行连接。PoolingHttpClientConnectionManager可以设置两个参数维护连接对应的每个后台主机连接池，以及全部连接池。setMaxPerRoute（默认值20）方法和setMaxTotal（默认值200）方法，前者设置请求同一个远程主机地址的本地tcp端口数量，后者则是HttpClient对象维护的整个tcp端口数量。例如，当setMaxPerRoute为2的时候，setMaxTotal为4的时候，并发请求3个相同的目的主机，httpclient首先启用两个本地tcp端口与远程主机通讯，当结果返回后，第三个请求才能执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实体类使用包装类型]]></title>
    <url>%2F2019%2F05%2F08%2Fnull%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot生产环境配置SSL证书问题]]></title>
    <url>%2F2019%2F05%2F08%2Fhttps%2F</url>
    <content type="text"><![CDATA[前言SpringBoot应用通过https协议访问，需要配置SSL证书，证书格式需要采用JKS。在application.properties增加以下几个配置：–server.ssl.key-store-type=JKS–server.ssl.key-store=.jks–server.ssl.key-password=在测试环境，一般是自行生成一个证书进行测试，但是部署到生产环境后会报以下异常：此网站无法提供安全连接，**用了不受支持的协议。 ERR_SSL_VERSION_OR_CIPHER_MISTACH。协议不受支持，客户端和服务器不支持一般SSL协议版本或加密套件。解决方法增加配置server.ssl.ciphers.1234--server.ssl.ciphers=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA_,SSL_RSA_WITH_RC4_128_SHA]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置Redis集群]]></title>
    <url>%2F2019%2F05%2F06%2Fnull%2F</url>
    <content type="text"><![CDATA[背景SpringBoot项目需要连接Redis集群，在网上查询了相关资料，很多都是连接一台localhost机器，或者采用Jedis进行操作。经过了解发现只需要]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Ajax跨域带cookie问题]]></title>
    <url>%2F2019%2F04%2F26%2Fcookie%2F</url>
    <content type="text"><![CDATA[背景项目需要用到SSO进行登录权限控制，项目G采用完全前后端分离的系统架构。项目G包括两个系统：前端系统A，域名A.ssss.com；后端系统B，域名B.ssss.com。前端和后端都通过Docker容器进行部署，前后端都具有多个Pod节点，每个Pod通过session黏连进行路由，也就是说根据上送的Cookie中的某个字段进行负载路由到容器节点。用户在SSO系统进行登录，登录成功后SSO系统会给项目G传入token，项目G对该token进行解密，得到用户id和用户姓名等信息，项目G还需要对登录态进行维护。问题项目主要存在以下几个问题：1、SSO系统回调系统A的地址还是系统B。2、不同域名，带cookie问题。3、前端Ajax请求后端API的鉴权问题。方案情形一、假如系统A和系统B部署在同一个域名下，鉴权流程如下所示：1、]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端API工程架构模块划分]]></title>
    <url>%2F2019%2F04%2F25%2Fspringboot%2F</url>
    <content type="text"><![CDATA[前言最近在做前后端分离的项目，在使用SpringBoot开发后端API系统的时候，要考虑系统的可维护和可扩展性以及充分解耦。模块可以分为API、Server、Service、Dao、Common 这五个moduleAPI模块：定义Http请求的接口，入参和出参的DTO数据模型。Server模块：实现Http请求的控制器，实现API模块定义的接口。Service模块：真正实现控制器中的业务逻辑，给控制器解耦，易于测试。Dao模块：采用JPA等框架实现ORM映射，PO持久层的数据模型定义。Common模块：放置一些通用类，比如工具类、AOP切面、过滤器等。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet和Controller分析]]></title>
    <url>%2F2019%2F04%2F25%2Fservlet%2F</url>
    <content type="text"><![CDATA[笔记在最初的JAVA Web编程的时候，可以编写多个Servlet来处理不同的请求映射，这种方式可以配置多个Servlet来响应请求。当引入了SpringMvc之后采用一个Servlet来处理全部的请求，通过dispatchServlet类，将不同路径的请求调用不同的Controller来执行。在SpringBoot阶段，只是简化了Spring的配置，原理相同。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot无法访问静态资源的问题]]></title>
    <url>%2F2019%2F04%2F23%2Fspringboot%2F</url>
    <content type="text"><![CDATA[原因在开发过程中，为了使请求路径大小写不敏感，编写了一个配置类，继承了WebMVCConfigurationSupport，导致有@EnableWebMvc注解，该注解将导致静态资源无法访问，需要手动设置静态资源路径。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SpringCloud Zuul过程中遇到的问题]]></title>
    <url>%2F2019%2F04%2F14%2Fzuul%2F</url>
    <content type="text"><![CDATA[背景使用SpringCloud Zuul开发一个可后台配置的网关系统，用户将转发规则写入数据库，Zuul网关启动的时候去数据库加载路由规则，进行请求转发。Zuul对接的后台服务不涉及服务注册与发现组件，从API接口捞取后台服务列表和地址，网关只需要根据规则将请求指向后台其中一台即可。采用Zuul该搭建该系统的原因在于，Zuul的转发原理可以让我们很方便的对请求的内容就行包装和处理。而基于Nginx做开发成本太高，涉及的编程语言门槛和其他一些因素。该网关系统采用@EnableZuulServer进行注解，无须涉及RibbonRoutingFilter。转发过程实际只需要根据规则将请求指向后台特定IP机器即可，因此该系统的route过滤器与SimpleHostRoutingFilter非常类似，完全可以基于SimpleHostRoutingFilter的源码做订制开发，从而来满足我们这个需求。请求URL编码问题通过网关发起的Get请求，到后台服务器时，上送的参数会被强制执行URLEncode。在SimpleHostRoutingFilter过滤器中，有一个参数forceOriginalQueryStringEncoding，顾名思义，强制采用原始请求的编码格式，即不对Get请求参数做编解码。SimpleHostRoutingFilter过滤器中构造HttpRequest的方法如下，构建HttpRequest12345678protected HttpRequest buildHttpRequest(String verb, String uri, InputStreamEntity entity, MultiValueMap&lt;String, String&gt; headers, MultiValueMap&lt;String, String&gt; params, HttpServletRequest request) &#123; HttpRequest httpRequest; String uriWithQueryString = uri + (this.forceOriginalQueryStringEncoding ? getEncodedQueryString(request) : this.helper.getQueryString(params)); ...&#125;该方法在构建url的时候，会根据forceOriginalQueryStringEncoding这个值执行不同的操作，当为true的时候，调用getEncodedQueryString方法，如下图所示，获取QueryString12345private String getEncodedQueryString(HttpServletRequest request) &#123; String query = request.getQueryString(); return (query != null) ? "?" + query : ""; &#125;&#125;可以看到，getEncodedQueryString方法直接返回request.QueryString，将不会对请求参数进行编解码操作。而this.helper.getQueryString方法会对请求参数做编解码处理。因此，只需要将forceOriginalQueryStringEncoding设置为true即可。该参数可以在Zuul的properties属性中配置，该参数在构造SimpleHostRoutingFilter中初始化的时候，是通过调用properties.isForceOriginalQueryStringEncoding()方法来进行初始化的。302重定向问题使用HttpClient进行通讯的过程中，如果遇到302、301这一类的重定向，HttpClient会自动发起二次请求，而这个时候的请求源IP则变成了网关地址，会造成IP漂移需要重新登录，因此需要将HttpClient的自动重定向禁用。将HttpClient的初始化改成HttpClientBuilder.create().disableRedirectHandling().build();增加一个disableRedirectHandling方法即可。请求Body编码问题这个问题源于Android客户端登陆时候遇到的，使用IPhone客户端登陆成功，但是Android客户端登陆失败。通过跟踪发现，Android客户端通过Post请求上送数据的时候，ContentType为application/x-www-form-urlencoded，而body中的数据为JSON格式。网关在处理的时候，经过FormBodyWrapperFilter会对数据进行编码，将body中的JSON格式编码转换，因此后台服务收到的数据是不正确的。IPhone之所以能登陆成功，是因为ContentType传的是application/json，FormBodyWrapperFilter的ShouldFilter方法会自动跳过这种情况。为了兼容已经在生产的客户端版本，网关采用禁用该过滤器的方式来解决该问题。通过在application.properites文件中增加zuul.FormBodyWrapperFilter.pre.disable=true配置。X-Forward-For与Host采用@EnableZuulServer和@EnableZuulProxy的一个区别就是，当使用@EnableZuulProxy作为注解的时候，会执行PreDecorationFilter过滤器，在该过滤器中会对请求头部做一些处理，比如带上以下参数：FilterConstants.java1234567891011121314151617181920/** * X-Forwarded-For Header */public static final String X_FORWARDED_FOR_HEADER = "X-Forwarded-For";/** * X-Forwarded-Host Header */public static final String X_FORWARDED_HOST_HEADER = "X-Forwarded-Host";/** * X-Forwarded-Prefix Header */public static final String X_FORWARDED_PREFIX_HEADER = "X-Forwarded-Prefix";/** * X-Forwarded-Port Header */public static final String X_FORWARDED_PORT_HEADER = "X-Forwarded-Port";/** * X-Forwarded-Proto Header */public static final String X_FORWARDED_PROTO_HEADER = "X-Forwarded-Proto";而在ZuulProperites类中可以看到，addProxyHeaders默认为true，addHostHeader默认为false。所以采用@EnableZuulProxy作为注解的时候，会带上Forwarded相关头部信息，不会带上Host头部信息。ZuulProperites.java123456789 /** * Flag to determine whether the proxy adds X-Forwarded-* headers. */private boolean addProxyHeaders = true;/** * Flag to determine whether the proxy forwards the Host header. */private boolean addHostHeader = false;而本网关高度订制化，采用@EnableZuulServer作为注解，因此需要手动对所需Forward相关参数和Host进行处理。IIS Request.Url 带端口号的问题由于网关后台对接了asp.net的IIS服务，使用了.net中的Request.Url.AbsoluteUri方法来取值，这个方法会自动拼接Host和端口。网关在测试环境中将会遇到问题，例如测试环境是网关地址99.6.140.1:808，而后台.net服务器地址是99.6.163.3:888。即使在网关中将Host设置为99.6.140.1:808，通过上述方法取得的值还是，99.6.163.3:808，自动拼接上了.net目的地址的端口。此问题目前还未找到解决方案，网关无法解决，只能通过.net后台服务进行修改。Transfer-Encoding:chunked 与 Content-LengthContent-Encoding:Gzip 自动解压httpclient disableContentCompress]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】用户态与内核态]]></title>
    <url>%2F2019%2F02%2F25%2Fuserandkernal%2F</url>
    <content type="text"><![CDATA[前言最近在学习Netty，学习五种IO模型，其中涉及一些时间片轮转，上下文切换的东西，自14年考完研后，这些东西都忘光了。百度搜索了一些关于用户态与内核态的知识，特记录一下以防遗忘。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud高版本的zuul路由状态查看]]></title>
    <url>%2F2019%2F01%2F16%2Fzuul%2F</url>
    <content type="text"><![CDATA[前言最近在研究SpringCloud Zuul的时候，发现通过 /routes无法查看路由信息，上网搜索了一些信息，发现都是低版本的SpringCloud的解决方案。Finchley版本和Greenwich版本并不适用。低版本的SpringCloud是基于springboot1 的版本，可以通过以下方式配置：1、引入spring-cloud-starter-zuul2、引入spring-boot-starter-actuator3、properties文件设置management.security.enabled=false4、访问/routes显示端点信息，访问/routes?format=details显示详细的端点信息SpringCloud高版本由于Finchley版本和Greenwich版本的Spring Cloud采用SpringBoot2.0，security的操作有改动，导致management.security.enabled=false会报错：Deprecated:A global security auto-configuration is now provided…”而且zuul的代码全部放到了Netflix包下，访问/routes的方式也有所变化，具体的操作步骤如下：1、引入spring-cloud-starter-netflix-zuul2、引入spring-boot-starter-actuator3、properties文件设置management.endpoints.web.exposure.include=*4、访问/actuator/routes显示端点信息，访问/actuator/routes/details显示详细的端点信息]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Gateway自定义过滤器实现IP Hash路由]]></title>
    <url>%2F2019%2F01%2F14%2FRouteToRequestUrl%2F</url>
    <content type="text"><![CDATA[现状公司转型微服务架构，将之前机器上所有已部署微服务拆分集群部署。微服务地址采用资源管理平台统一管理维护，包括微服务IP、集群数据等，未采用服务注册与发现组件。需求1、从资源管理平台获取服务器IP地址等相关参数；2、相同源IP转发到相同服务器，采用IP Hash方式；实现SpringCloud Gateway支持自定义过滤器，通过继承RouteToRequestUrlFilter类来实现IP Hash。SpringCloud Gateway过滤器分为两类，Gateway Filter和Global Filter，前者是针对匹配命中的过滤，有两种方式来实现，实现GatewayFilter接口、继承AbstractGatewayFilterFactory类，后者是针对全局路由的过滤器，可以采用添加@Component注解的方式来注册。SpringCloud Gateway的全局过滤器如下图所示：我们需要做的就是实现一个自定义的全局过滤器CustomRouteToRequestUrlFilter，在该过滤器中设置IP Hash后的真实URL地址。代码如下：CustomRouteToRequestUrlFilter.java1234567891011121314151617181920212223@Component public class CustomRouteToRequestUrlFilter extends RouteToRequestUrlFilter &#123; private List&lt;String&gt; mUrlList = new ArrayList&lt;String&gt;() &#123; &#123; add("http://10.0.0.1"); add("http://10.0.0.2"); add("http://10.0.0.3"); &#125; &#125;; @Override public int getOrder() &#123; return 10001; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; ServerHttpRequest request = exchange.getRequest(); String address = request.getRemoteAddress().getAddress().getHostAddress(); int num = Math.abs(address.hashCode()) % mUrlList.size(); URI mergedUrl = URI.create(mUrlList.get(num)); exchange.getAttributes().put(ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR, mergedUrl); return chain.filter(exchange); &#125;&#125;以上代码可以进行优化，通过处理”x-forward-for”以获取真实IP地址。此处暂略。WebFlux通过ServerWebExchange类来处理Http Request和Http Response。首先取得IP地址，然后将IP地址做Hash得到一个整型，再根据服务器数量求余，最后得到所选择的服务器。以上代码需要注意的地方在于，需要设置Order为10001，大于RouteToRequestUrlFilter的返回值（10000），这样才能将优先级置于RouteToRequestUrlFilter之下。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>IP Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Gateway基于静态URL的Ribbon负载均衡]]></title>
    <url>%2F2019%2F01%2F09%2FgatewayRibbon%2F</url>
    <content type="text"><![CDATA[前言SpringCloud Gateway是Netflix旗下开源的API网关，项目比较新，网上资源也比较少，因此坑比较多吧。说到SpringCloud Gateway，肯定都会与Zuul进行对比。Zuul分为Zuul1和Zuul2两个版本，Zuul1是采用同步阻塞的方式，使用多线程来实现，而Zuul2则是采用异步非阻塞的事件驱动。SpringCloud Gateway与Zuul2一样，基于异步非阻塞的事件驱动。而SpringCloud Zuul则是采用的Zuul1这个同步阻塞的方式，可能是由于Zuul2出来比较慢，Netflix等不及了，就自己搞了一个异步非阻塞的SpringCloud Gateway。有人在Github提问，SpringCloud 后续是否会集成Zuul2，官方给了否定答复。既然都有了异步非阻塞的Gateway，那么也就没必要再集成Zuul2到SpringCloud了。两者的性能对比（zuul1和Gateway），https://github.com/spencergibb/spring-cloud-gateway-bench 。ProxyAvg LatencyAvg Req/Sec/Threadgateway6.61ms3.24klinkered7.62ms2.82kzuul12.56ms2.09knone2.09ms11.77k需求1、根据配置，将指定源IP路由到某台特定的服务器，以便灰度发布验证。2、采用Web端进行路由配置更新。3、默认规则，采用IP Hash路由到固定服务器。根据以上三个需求点，只需要使用API网关与负载均衡器，不需要服务注册与发现组件，因此需要采用静态URL进行路由配置。根据多方面权衡以及业务可行性分析，技术栈决定采用SpringCloud Gateway。原因有以下几点：1、Gateway支持 RemoteAddr Route Predicate Factory，可以满足需求点1。2、Gateway支持 Actuator API，支持RestFul刷新路由配置，可以满足需求点2。3、采用Ribbon，自定义路由规则，以及支持静态服务器地址配置，可以满足需求点3。实现application.yml12345678910111213141516171819202122spring: cloud: gateway: routes: -id: wpstan uri: lb://customRibbon predicates: -RemoteAddr=99.6.150.163ribbon: eureka: enabled: false //必须要关闭eureka的服务注册与发现customRibbon: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule //随机规则 listOfServers: http://99.12.98.215:8080,http://99.12.98.215:8081,http://99.12.98.215:8082management: endpoints: web: exposure: include: '*'//配置actuator api使用，暴露端点 第六行的lb表示匹配规则为loadBalance负载均衡，规则名为customRibbon。第十二行表示该负载均衡规则采用Ribbon，后面就是Ribbon的配置。主要就是listOfServers这个静态URL配置，由于我不需要去动态获取服务注册与发现，因此可以在此写死。需要注意的就是必须要把ribbon.eureka.enabled置为false。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构简介（单一架构VS微服务架构）]]></title>
    <url>%2F2019%2F01%2F03%2Fmicsvrintroduce%2F</url>
    <content type="text"><![CDATA[前言最近，关于微服务有很多争论。几乎所有的IT公司都在讨论微服务。当我们将微服务跟传统的单一架构比较时，可以很容易理解它。几乎每个企业应用都有相似的分层架构：1.表现层：用户的交互界面。2.业务逻辑：应用的内在业务逻辑。3.数据库访问：几乎所有的应用都需要访问数据库，SQL或NoSQL都行。4.应用集成：应用之间交互是相当常见的。这些通常是通过Web服务调用（SOAP或REST）或消息传递来实现的。即使应用有清晰的、逻辑上模块化架构，但是，大部分应用会被作为单一架构打包和发布。这么做是有一定优势的。单一架构的优势1.开发相当简单。2.测试也非常简单。仅仅启动应用，然后开始端对端的测试。我们也能毫无困难的使用Selenium进行自动化测试。3.部署单一应用程序是很简单;只需将打包的应用程序复制到服务器。4.扩展是很简单的。我们仅仅需要增加单一架构的新实例。并通过负载均衡器将负载分配到新实例上，但是，随着整体应用程序的规模增长，可伸缩性将成为一个严重的问题。单一架构的劣势1.灵活性: 单一架构不够灵活。我们不能使用不同的技术。技术堆栈从一开始就决定了，并自始至终遵循。一旦开发成熟，有时就很难升级技术堆栈版本，更不用说增量地采用新技术了。2.可靠性: 不可靠。如果一个特性出现故障，整个应用程序可能会出现故障。3.开发速度: 单一架构的开发非常缓慢。对于新的团队成员来说，理解和修改大型单一架构应用程序的代码是很困难的。代码质量会随着时间的推移而下降。随着代码库的增大，IDE会过载，速度会变慢。应用程序越大，启动时间越长。所有这些因素都会对开发人员的生产力产生巨大的影响。4.构建复杂应用: 由于技术方面的限制，很难构建复杂的应用程序。5.可伸缩性: 单一架构的应用程序一旦变大，就很难扩展。我们可以创建新的单体实例，并要求负载均衡器将流量分配给新的实例，但是整体架构不能随着负载的增加而扩展。应用程序实例的每个副本都将访问所有数据，这将降低缓存的效率，并增加内存消耗和I/O流量。而且，不同的应用程序组件有不同的资源需求——一个可能是CPU密集型组件，而另一个可能是内存密集型组件。使用单一架构，我们不能独立地扩展每个组件。6.持续部署: 持续部署极其困难。大型单一架构的应用程序实际上是频繁部署的一个障碍。为了更新一个组件，我们必须重新部署整个应用程序。由于上述单一架构应用程序的缺点，微服务体系结构正日益受到人们的欢迎。那么什么是基于微服务的体系结构呢?简而言之，微服务体系结构风格是一种将单一架构应用程序开发为一组小服务的方法，每个小服务都在自己的流程中运行，并与轻量级机制通信(通常通过RESTful web服务或消息传递)。这些服务是围绕业务功能构建的，可以通过完全自动化的部署机制独立部署。这些服务的集中化管理非常少，它们可能使用不同的编程语言开发，使用不同的数据存储技术。微服务是小型的、可独立部署的、支持云计算的单元。微服务架构如何解决单一架构的缺点1.灵活性: 微服务体系结构非常灵活。不同的微服务可以用不同的技术开发。由于微服务更小，代码基础就更少了，所以升级技术堆栈版本并不是那么困难。而且，我们可以毫无困难地逐步采用新技术。2.可靠性: 微服务体系结构可以非常可靠。如果一个功能崩溃，整个应用程序就不会崩溃。我们可以在相应的微服务中修复这个问题并立即部署它。3.开发速度: 微服务体系结构中的开发非常快。由于微服务的代码量要小得多，因此新团队成员理解和修改代码并不困难。他们从一开始就很有成效。代码质量维护良好。IDE要快得多。微服务的启动时间要短得多。所有这些因素都大大提高了开发人员的生产力。4.构建复杂的应用程序: 使用微服务体系结构，很容易构建复杂的应用程序。如果正确地分析应用程序的特性，我们可以将其分解为独立的组件，这些组件可以独立部署。然后，甚至独立组件也可以进一步分解为小的独立任务，这些任务可以作为微服务独立部署。确定微服务的边界非常具有挑战性。这实际上是一个渐进的过程，但是一旦我们决定使用微服务，就很容易开发，因为在技术上没有限制。5.可伸缩性: 可伸缩性是微服务体系结构中的一个主要优点。每个微服务可以单独缩放。由于单个微服务的大小要小得多，因此缓存变得非常有效。6.持续部署: 持续部署变得更容易。为了更新一个组件，我们只需要重新部署那个特定的微服务。正如我前面提到的，当我们将微服务体系结构与传统的单一体系结构进行比较时，可以很容易地理解它，但是在微服务之前，已经有类似的体系结构可用。是的，我说的是SOA(面向服务的体系结构)。SOA已经存在了20年。如果您已经使用过SOA并熟悉它的概念，那么理解SOA和微服务体系结构之间的差异可能会非常令人困惑。事实上，两者的共同点多于不同点。在下一篇关于微服务的文章中，我将介绍SOA、SOA和微服务体系结构之间的相似性，当然还有它们之间的区别。（转自IT牧场）]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用DNS实现服务发现]]></title>
    <url>%2F2018%2F12%2F07%2Fdns%2F</url>
    <content type="text"><![CDATA[前言众所周知，DNS的作用是将域名转成IP，进而让客户端浏览器获取主机的IP地址进行HTTP通信。DNS服务器中，域名能够关联各种不同类型的资源。除了我们非常熟悉的A解析（解析成IP地址）或者是CNAME解析（解析成别的域名）等，DNS还可以提供其他一些资源的解析，例如SRV（服务定位）、PTR（其他域名引用）以及TXT（文本数据）。DNS解析A记录将域名解析成IPV4的形式。AAAA记录将域名解析成IPV6的形式。CNAME将域名解析成其他域名。MX邮件服务器地址解析。TXT将域名解析成文本文件类型。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 简介]]></title>
    <url>%2F2018%2F11%2F28%2Fspringboot%2F</url>
    <content type="text"><![CDATA[前言作为一个SpringBoot新人，在学习中有诸多疑惑，慢慢梳理出来、但求拨云见日。SpringBoot和SpringSpring是容器，是管理对象生命周期的容器。开发的时候，由Spring容器来处理对象的生命周期。Spring容器能够帮助我们来管理生命周期的前提是我们需要对Spring进行配置。而SpringBoot的出现，简化了这种XML的配置过程，这也是SpringBoot的一大优势。当然，SpringBoot也不单单仅有这一个优势，更多的优势可以自行百度一下。HelloWorldSpringBoot自带了java web服务器，引入SpringBoot后，在main方法中注册Application启动类，即可运行。页面输出HelloWorld，需要配置一个@Controller，用来响应浏览器请求。控制器@Controller 用来处理http的请求，@RestController用来返回Json数据格式，@RequestMapping用来配置Url映射。可以使用GetMapping来简化Get操作。Controller1234567public class HelloController &#123; @RequestMapping(value = "/hello",method = RequestMethod.GET)//等价于@GetMapping(value="/hello") @ResponseBody public String sayHello() &#123; return "Hello，Spring Boot！"; &#125;&#125;当注解写成@RestController的时候，可以直接返回一个序列化的JSON对象。下面的代码将返回一个JSON格式的User对象。RestController12345678@RestController@RequestMapping("/config")public class ConfigController &#123; @RequestMapping("/hr") public User currentUser() &#123; return UserUtils.getCurrentUser(); &#125;&#125;Controller可以返回字符串，可以返回序JSON列化后的对象，那要怎么返回HTML页面呢？可以使用前端页面模板。thymeleaf首先在配置文件中引入thymeleaf的包，然后再Controller中编写响应请求代码，返回html的页面名字。其中，ModelMap是用来与Html页面进行数据交互的。Controller12345@RequestMapping(method = RequestMethod.GET)public String getBookList(ModelMap map) &#123; map.addAttribute("bookList",bookService.findAll()); return "bookList";&#125;bookList.html的页面部分内容如下所示：bookList.html1234567&lt;tr th:each="book : $&#123;bookList&#125;"&gt; &lt;th scope="row" th:text="$&#123;book.id&#125;"&gt;&lt;/th&gt; &lt;td&gt;&lt;a th:href="@&#123;/book/update/&#123;bookId&#125;(bookId=$&#123;book.id&#125;)&#125;" th:text="$&#123;book.name&#125;"&gt;&lt;/a&gt;&lt;/td&gt; &lt;td th:text="$&#123;book.writer&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;book.introduction&#125;"&gt;&lt;/td&gt; &lt;td&gt;&lt;a class="btn btn-danger" th:href="@&#123;/book/delete/&#123;bookId&#125;(bookId=$&#123;book.id&#125;)&#125;"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;数据库操作SpringBoot可以方便的连接多种数据库，比如MySql，ElasticSearch等。在学习过程中梳理出了以下几个需要了解的点：ORM框架主流的有hibernate以及mybatis，区别在于前者无须写sql，通过对象操作数据库，后者通过编写更加灵活的sql语句来操作数据库。ORM是JPA规范中的一个思想体现，JPA规范包含了ORM。JPA、spring-data-jpa、hibernate三者之间的关系，JPA是Java Persistence API缩写，是JAVA持久化规范，spring-data-jpa对具体的JPA实现做了封装，默认采用hibernate实现，能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。操作步骤：1、引入spring-data-jpa；2、编写Entity类；3、编写Repository类；4、调用方法Book.java123456789@Entitypublic class Book implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String writer; ....get set ....BookRepository.java12345/** * Book 数据持久层操作接口 */public interface BookRepository extends JpaRepository&lt;Book, Long&gt; &#123;&#125;BookServiceImpl.java1234567891011121314/** * Book 业务层实现 */@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired BookRepository bookRepository; @Override public List&lt;Book&gt; findAll() &#123; return bookRepository.findAll(); &#125;......从上面代码中可以看到，在业务服务层只需要引入BookRepository后，就可以操作数据库中相关数据，很方便。已经具备了搭建一套对外服务的功能，包括响应请求、操作数据、返回数据。代码结构规范的SpringBoot工程分层结构应该包括如下项：应用监控sprig-boot-starter-actuatorSpringCloud]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的gitment评论报错]]></title>
    <url>%2F2018%2F11%2F28%2Fhexogitmenterror%2F</url>
    <content type="text"><![CDATA[Gitment报错今天发现我博客hexo采用的github issue的评论系统gitment出现了以下报错：所有评论Error: API rate limit exceeded for 107.178.194.84. (But here’s the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)解决方案：无需解决原因：这是github的自我保护机制，防止未登陆用户重复调用API。点击下方github登陆按钮登陆后，错误消失。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XX-Net科学上网]]></title>
    <url>%2F2018%2F11%2F28%2Fxxnet%2F</url>
    <content type="text"><![CDATA[前言Great Wall 不多说，中国特色，哈哈哈。XX-Net这个跟之前用的GoAgent貌似一样的原理，先去谷歌申请一个小应用程序，然后利用这个来科学上网。详细介绍都在GitHub上XX-Net，目前有25539个星。可以自己去谷歌申请appid，也可以用xx-net自带的。网速还可以，目前用的最好用的科学上网工具，支持windows、mac、Android。本方法需要ipv6隧道，如果用mac连接手机热点，且手机支持4G，则可以直接上网。如果是宽带，需要配置ipv6协议，教程上有详细说明。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo next主题SEO优化]]></title>
    <url>%2F2018%2F11%2F21%2Fhexoseo%2F</url>
    <content type="text"><![CDATA[前言我在大学期间使用过ZBlog、WordPress等博客系统。而Hexo与这两者的区别在于，Hexo是静态博客系统。Hexo无需数据库作为存储，也无需服务器端渲染，直接将页面以Html的格式输出给用户。全球最大男性交友社区github提供了GitPage解决方案，使得开发者可以直接将静态Html页面发布到web上。这样也避免了购买web云服务器，却只用来处理静态页面的不划算，免费的总是最好的。GitPage我们可以将Hexo生成的页面push到GitPage中来发布，GitPage是Github提供的个人页面的个性化展示空间。可以通过创建一个Repository，进入设置页面激活GitPage，而后可以通过 (用户名.github.io) 的方式访问。wpstan.github.io。GitPage非常友好的提供了域名映射，我们可以使用自己简短的域名来访问博客，例如本站的域名tanRD.com。SEO 之 keywords搜索引擎会在页面的&lt;head>标签中查询&lt;keywords>的mete定义，收录时会根据keywords进行索引，因此这个很有必要进行优化。打开_config.yml文件，找到keywords所在的行，添加自己希望通过搜索引擎索引的关键字。关键字个数五六个应该就差不多了，关键字个数对搜索引擎的具体影响，我也不懂。上述改动是针对首页的关键字优化，我们还必须优化每一个文章页面的keywords,打开/themes/next/layout/_partials/head.swig文件，找到以下代码：通过上述代码可以知道，next首先去页面上找keywords，没有就使用tags标签来设置keywords值，再没有就使用主题设置的keywords。我这里将keywords在页面脚手架中定义，使得在new 文章的时候，默认带上这个参数，这样就可以自定义添加keywords了。同时修改上述代码，将页面中自定义的keywords以及页面标签作为最后的keywords。下面是本文的顶部标题，title: Hexo next主题SEO优化 date: 2018-11-21 19:10:30 url_suffix: hexoseo tags: [&apos;hexo&apos;,&apos;seo&apos;] categories: 博客 keywords: [&apos;next&apos;,&apos;搜索引擎优化&apos;] 最终在本页面中得到的keywords如下图所示：可以看到有两个keywords属性，上方的是刚才代码拼接的结果，下方的是Hexo自带的，可以删除这个自带的。打开文件路径：/Hexo/node_modules/hexo/lib/plugins/helper/open_graph.js，将下方代码注释掉即可。if (keywords) { if (typeof keywords === &apos;string&apos;) { result += meta(&apos;keywords&apos;, keywords); } else if (keywords.length) { result += meta(&apos;keywords&apos;, keywords.map(tag =&gt; { return tag.name ? tag.name : tag; }).filter(keyword =&gt; !!keyword).join()); } } SEO 之 静态URL静态URL是指当前页面的地址不会变动，永久存在的网页地址。搜索引擎喜欢收录静态URL，以静态URL作为当前收录页面的索引。如果说当前文章页面经常改动，可想而知，搜索引擎难以收录。Hexo默认是按照日期和文章名字生成当前文章的URL地址，可以查看_config.yml文件，找到permalink这个配置。# URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://www.tanrd.com root: / permalink: :year/:month/:day/:url_suffix/ permalink_defaults: 我这里增加了url_suffix作为URL后缀，默认是以文章的文件名拼接URL。而我文件名可能需要设置成中文，方便我查找，但是中文文字在地址栏会被HTML Encode转成html编码，将导致链接很长。因此这里我设置了一个url_suffix，主动设置文章后缀名。这个url_suffix地址在文章中不应该经常修改，特别是搜索引擎收录之后，修改地址将会导致搜索以前之前收录的链接变成死链，无法访问，非常不利于SEO。因此在创建文章的时候，手动设置了这个url_suffix后，就不要再修改了。在SEO之keywords这个章节中，我已经展示了我这个文章的定义头部分，可以看到url_suffix设置的是hexoseo。在地址栏中显示的地址是http://www.tanrd.com/2018/11/21/hexoseo/SEO 之 百度搜索引擎由于之前百度爬虫将github搞挂了，github屏蔽了百度爬虫的抓取。但是没有关系，我们可以采用github的pages和coding的pages来发布自己的博客。coding这个公司已经被腾讯收购，是国内的一家类似github的网站，国内比较出名的git平台还有码云，我们公司最近也引入码云。我这个域名www.tanrd.com 是通过阿里云购买的，在域名解析的时候，只需将百度爬虫解析到国内的coding page即可。在解析的时候选择CNAME将百度指向coding的pages地址，这个意思是将百度爬虫的DNS解析指向国内的coding pages，我这里是wpstan.coding.me。阿里云非常方便的给我们提供了解析线路选择，有多种选择，根据自己需求来决定。除了百度指向coding的pages，其他的线路都默认指向github的pages，毕竟github的CDN很多，网速也还能接受。SEO 之 SiteMapSitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。我这里搞了两sitemap，一个是sitemap.xml，可以打开https://www.tanrd.com/sitemap.xml访问；一个专门针对百度的baidusitemap.xml，地址是https://www.tanrd.com/baidusitemap.xml。在Hexo中安装很容易，只需要执行如下命令即可：npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --saveSEO 之 robots.txt这个文件的作用是制定搜索引擎的爬取规则，所有正规搜索引擎都遵守该标准。新建robots.txt放在source的根目录下，修改其中内容为：User-agent: * Allow: / Allow: /archives/ Allow: /categories/ Allow: /tags/ Allow: /about/ Disallow: /js/ Disallow: /images/ Disallow: /css/ Disallow: /fonts/ Sitemap: http://www.tanrd.com/sitemap.xml Sitemap: http://www.tanrd.com/baidusitemap.xml 本站的robots.txt地址为http://www.tanrd.com/robots.txtSEO 之 nofollow当搜索引擎在爬取文章页面的时候，如果文章中有外链，可能会将爬虫引出我们的网站，因此有必要屏蔽这种情况。首先安装hexo-autonofollownpm install hexo-autonofollow --save再在外层_config.yml中添加配置，将nofollow设置为true：# 外部链接优化 nofollow: enable: true exclude: # 例外的链接，可将友情链接放置此处 - &apos;yousite&apos; 再重新生成的时候，可以看到出站链接自动加上了一系列参数：&lt;a href=&quot;https://github.com/XX-net/XX-Net&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;XX-Net&lt;/a&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序云开发]]></title>
    <url>%2F2018%2F11%2F19%2Fclouddev%2F</url>
    <content type="text"><![CDATA[前言微信小程序依托微信平台，给用户提供类似App的操作体验。俗话说一流公司订标准，小程序开发语言规范由Tencent制定。小程序开发需要了解前端相关知识，JS、HTML、CSS足以。学习过前端MVVM框架的开发人员，可以很容易上手。闲来无事，周末在家倒腾了一下小程序开发，在这里记录一下心得。小程序云开发一般来说开发一个App或者Web页面，都需要一个服务提供者，用来存储用户相关数据，或者给Web页面提供服务端渲染来完成与用户之间交互。但是微信出了一个小程序云开发，可以直接充当云端数据库，看起来特别牛逼的样子。这样一来，就不需要购买各种云服务器来提供服务了。小程序云开发可以让用户在云端编写JS Function函数，相当于FaaS平台（函数即服务）。微信提供免费基础版云平台套餐给开发者使用，开发者也可以花钱升级套餐。我以个人身份注册了一个小程序，个人身份的开发者貌似只能开发一些特定类目的小程序，比价、教育什么的。本人开发了一个小App，后续见github。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next - Gemini主题修改]]></title>
    <url>%2F2018%2F10%2F19%2Fgeminimodify%2F</url>
    <content type="text"><![CDATA[前言在Hexo的模板中选择了Next主题，在Next主题中看中了Gemini风格的页面。但是有一些小点不符合本人审美，特意修改了一下，以满足我自己的视觉体验。页面宽度修改chrome浏览器F12查看到页面的内容宽度占比为75%，找到themes中的next文件夹，进入/source/css/_variables/目录，打开Gemini.styl文件。可以看到以下内容：也可以设置$body-bg-color，改变页面背景色。页面底部主题信息删除打开themes中的next文件夹，找到_config.yml文件，修改footer下面的配置为false即可。copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false 页面顶部黑色线条删除打开themes中的next文件夹，找到/source/css/_common/components/header/headerband.styl文件，删除background样式即可。.headband { height: $headband-height; background: $headband-bg; } 静态资源压缩可以通过安装hexo-all-minifier来进行静态资源压缩，减少网络请求时候的数据包，加快网站响应速度。可以对html、css、js、images进行压缩，即把重复的代码合并，把多余的空格去掉，用算法对images进行压缩。npm install hexo-all-minifier --save再在外层_config.yml中添加配置，可以分别对html、js、css、image进行处理： html_minifier: enable: true ignore_error: false exclude: css_minifier: enable: true exclude: - &apos;*.min.css&apos; js_minifier: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos; image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false 再重新生成的时候，可以看到页面上的静态资源已经被压缩，Size这一栏数据量有所减少。下面是压缩前后的传输数据量对比： 代码高亮第一种方式：首先安装 hexo-prism-plugin插件，执行如下命令：npm install hexo-prism-plugin --save 然后修改_config.yml，添加如下配置：prism_plugin: mode: &apos;preprocess&apos; # realtime/preprocess theme: &apos;default&apos; line_number: false # default false custom_css: &apos;path/to/your/custom.css&apos; # optional 相关配置字段说明如下：mode:realtime (在浏览器实时解析代码)preprocess (在node环境中先解析代码)theme:defaultcoydarkfunkyokaidiasolarizedlighttomorrowtwilightatom-darkbase16-ateliersulphurpool.lightcbduotone-darkduotone-earthduotone-forestduotone-lightduotone-seaduotone-spaceghcolorshopscotchpojoaquevsxonokailine_number:true (显示行号)false (默认, 隐藏行号)no_assetstrue (停止加载资源文件)false (默认, 加载js和css文件)第二种方式：直接用自带的next主题，可以在配置文件中修改自己喜欢的样式# Code Highlight theme # Available value: # normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: night 在写博客插入代码的时候，需要指定开发语言，才会显示不同的颜色样式。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gemini</tag>
      </tags>
  </entry>
</search>
